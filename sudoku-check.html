<!--Generated from gemini-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Sudoku Validator & Solver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
            background-color: #f1f5f9; /* Light slate background */
        }
        
        /* --- General Appearance --- */
        .card {
            background-color: white;
            border-radius: 1.5rem; /* More rounded */
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
        }

        /* --- Input Customization --- */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }

        /* --- Sudoku Grid Styling --- */
        #sudoku-grid {
            aspect-ratio: 1 / 1;
            border: 3px solid #1e293b; /* Dark slate border */
            background-color: #cbd5e1; /* Lighter slate for grid lines */
            gap: 1px;
            border-radius: 0.5rem;
            overflow: hidden; /* Ensures inner cells conform to border-radius */
        }
        
        .sudoku-cell {
            transition: background-color 0.2s ease-in-out;
            border: none;
            font-size: clamp(1rem, 4.5vw, 1.75rem);
            caret-color: #3b82f6;
            border-radius: 0;
            background-color: #ffffff;
            color: #3b82f6; /* Blue for user-entered numbers */
        }
        
        .sudoku-cell:focus {
            outline: none;
            background-color: #eff6ff; /* Very light blue on focus */
        }

        /* --- Grid Lines --- */
        .sudoku-cell[data-col="2"],
        .sudoku-cell[data-col="5"] {
            border-right: 2px solid #334155;
        }

        .sudoku-cell[data-row="2"],
        .sudoku-cell[data-row="5"] {
            border-bottom: 2px solid #334155;
        }

        /* --- Cell States --- */
        .initial-value {
            color: #1e293b; /* Dark slate for initial numbers */
            font-weight: 600;
        }

        .solved {
             background-color: #ecfdf5 !important;
             color: #047857;
             font-weight: 600;
        }
        .invalid {
            background-color: #fef2f2 !important;
            color: #b91c1c;
            position: relative;
        }
        .invalid::after { /* Small visual indicator for invalid cells */
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 6px;
            height: 6px;
            background-color: #ef4444;
            border-radius: 50%;
        }

        .highlight {
            background-color: #e0e7ff !important;
        }

        /* --- Button Styling --- */
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            border: none;
            cursor: pointer;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .btn-primary {
            background-color: #2563eb;
            color: white;
        }
        .btn-primary:hover {
             background-color: #1d4ed8;
        }
        .btn-secondary {
            background-color: #475569;
            color: white;
        }
        .btn-secondary:hover {
             background-color: #334155;
        }
        .btn-danger {
            background-color: #dc2626;
            color: white;
        }
         .btn-danger:hover {
             background-color: #b91c1c;
        }
        .btn svg {
            width: 1.25rem;
            height: 1.25rem;
        }

    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="card p-4 sm:p-8 max-w-lg w-full">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-slate-800">Sudoku Pro</h1>
            <p class="text-slate-500 mt-2">A modern tool to validate and solve your favorite puzzles.</p>
        </div>
        
        <div id="sudoku-grid" class="grid grid-cols-9 shadow-lg mb-8">
            <!-- Cells generated by JS -->
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
            <button id="validate-btn" class="btn btn-primary">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                Validate
            </button>
            <button id="solve-btn" class="btn btn-secondary">
                 <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.562L16.25 22.5l-.648-1.938a3.375 3.375 0 00-2.6-2.6L11.25 18l1.938-.648a3.375 3.375 0 002.6-2.6L16.25 13l.648 1.938a3.375 3.375 0 002.6 2.6l1.938.648-1.938.648a3.375 3.375 0 00-2.6 2.6z" /></svg>
                Solve
            </button>
            <button id="clear-btn" class="btn btn-danger">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12.548 0c-.04.03-.078.062-.115.098m12.778 0c-.04.03-.078.062-.115.098m-12.548 0l-3.376 3.376a2.25 2.25 0 00-.653 1.585l.504 9.074a2.25 2.25 0 002.244 2.077h8.51a2.25 2.25 0 002.244-2.077l.504-9.074a2.25 2.25 0 00-.653-1.585l-3.376-3.376m-7.642 0A48.1 48.1 0 0112 4.5c4.73 0 9.243 1.096 13.195 3.033" /></svg>
                Clear
            </button>
        </div>
        
        <div id="message-area" class="text-center p-3 rounded-lg text-lg font-medium min-h-[50px] transition-all duration-300">
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gridContainer = document.getElementById('sudoku-grid');
            const validateBtn = document.getElementById('validate-btn');
            const clearBtn = document.getElementById('clear-btn');
            const solveBtn = document.getElementById('solve-btn');
            const messageArea = document.getElementById('message-area');
            const cells = [];

            // A sample puzzle to start with
            const initialPuzzle = [
                [5, 3, 0, 0, 7, 0, 0, 0, 0],
                [6, 0, 0, 1, 9, 5, 0, 0, 0],
                [0, 9, 8, 0, 0, 0, 0, 6, 0],
                [8, 0, 0, 0, 6, 0, 0, 0, 3],
                [4, 0, 0, 8, 0, 3, 0, 0, 1],
                [7, 0, 0, 0, 2, 0, 0, 0, 6],
                [0, 6, 0, 0, 0, 0, 2, 8, 0],
                [0, 0, 0, 4, 1, 9, 0, 0, 5],
                [0, 0, 0, 0, 8, 0, 0, 7, 9]
            ];

            function createGrid() {
                for (let i = 0; i < 9; i++) {
                    for (let j = 0; j < 9; j++) {
                        const cell = document.createElement('input');
                        cell.type = 'number';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.className = `sudoku-cell w-full h-full text-center font-semibold`;
                        
                        cell.addEventListener('input', () => {
                            if (cell.value && (cell.value.length > 1 || !/^[1-9]$/.test(cell.value))) {
                                cell.value = cell.value.slice(-1);
                            }
                        });

                        cell.addEventListener('focus', () => highlightRelated(i, j));
                        cell.addEventListener('blur', clearHighlights);

                        gridContainer.appendChild(cell);
                        cells.push(cell);
                    }
                }
            }
            
            function loadPuzzle(puzzle) {
                cells.forEach((cell, index) => {
                    const row = Math.floor(index / 9);
                    const col = index % 9;
                    const value = puzzle[row][col];

                    cell.classList.remove('initial-value', 'solved', 'invalid');
                    cell.readOnly = false;
                    
                    if (value !== 0) {
                        cell.value = value;
                        cell.classList.add('initial-value');
                    } else {
                        cell.value = '';
                    }
                });
            }

            // --- Board State Management ---

            function getBoardState() {
                const board = Array(9).fill(null).map(() => Array(9).fill(0));
                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row, 10);
                    const col = parseInt(cell.dataset.col, 10);
                    board[row][col] = cell.value ? parseInt(cell.value, 10) : 0;
                });
                return board;
            }

            function setBoardState(board, originalBoard) {
                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row, 10);
                    const col = parseInt(cell.dataset.col, 10);
                    const value = board[row][col];
                    cell.value = value !== 0 ? value : '';
                    cell.classList.remove('solved', 'invalid');
                    if (originalBoard[row][col] === 0 && value !== 0) {
                        cell.classList.add('solved');
                    }
                });
            }
            
            function clearBoard() {
                cells.forEach(cell => {
                    cell.value = '';
                    cell.classList.remove('invalid', 'solved', 'initial-value');
                });
                showMessage('', 'clear');
                clearHighlights();
            }

            // --- UI Interaction and Feedback ---

            function highlightRelated(row, col) {
                clearHighlights();
                cells.forEach(cell => {
                    const r = parseInt(cell.dataset.row);
                    const c = parseInt(cell.dataset.col);
                    const boxRowStart = Math.floor(row / 3) * 3;
                    const boxColStart = Math.floor(col / 3) * 3;
                    
                    if (r === row || c === col || 
                        (r >= boxRowStart && r < boxRowStart + 3 && c >= boxColStart && c < boxColStart + 3)) {
                        cell.classList.add('highlight');
                    }
                });
            }

            function clearHighlights() {
                cells.forEach(cell => cell.classList.remove('highlight'));
            }

            function showMessage(text, type) {
                messageArea.textContent = text;
                messageArea.className = 'text-center p-3 rounded-lg text-lg font-medium min-h-[50px] transition-all duration-300'; // Reset classes
                switch (type) {
                    case 'success':
                        messageArea.classList.add('bg-green-100', 'text-green-800');
                        break;
                    case 'error':
                        messageArea.classList.add('bg-red-100', 'text-red-800');
                        break;
                    case 'clear':
                         messageArea.classList.add('bg-transparent');
                        break;
                }
            }

            function highlightInvalidCells(invalidCells) {
                 cells.forEach(cell => cell.classList.remove('invalid'));
                 invalidCells.forEach(({row, col}) => {
                     const cell = cells[row * 9 + col];
                     if(cell) cell.classList.add('invalid');
                 });
            }

            // --- Sudoku Logic ---

            function validateCurrentBoard() {
                const board = getBoardState();
                cells.forEach(cell => cell.classList.remove('invalid'));
                const { isValid, invalidCells } = isValidSudoku(board);

                if (isValid) {
                    showMessage('This is a valid Sudoku state!', 'success');
                } else {
                    showMessage('This Sudoku is invalid. See highlighted cells.', 'error');
                    highlightInvalidCells(invalidCells);
                }
            }

            function isValidSudoku(board) {
                const duplicates = new Set();

                for (let i = 0; i < 9; i++) {
                    const rowSeen = new Map();
                    const colSeen = new Map();
                    for (let j = 0; j < 9; j++) {
                        const rowVal = board[i][j];
                        const colVal = board[j][i];
                        if (rowVal !== 0) {
                            if (rowSeen.has(rowVal)) {
                                duplicates.add(`${i}-${j}`);
                                duplicates.add(`${i}-${rowSeen.get(rowVal)}`);
                            }
                            rowSeen.set(rowVal, j);
                        }
                        if (colVal !== 0) {
                            if (colSeen.has(colVal)) {
                                duplicates.add(`${j}-${i}`);
                                duplicates.add(`${colSeen.get(colVal)}-${i}`);
                            }
                            colSeen.set(colVal, j);
                        }
                    }
                }

                for (let box = 0; box < 9; box++) {
                    const seen = new Map();
                    const startRow = Math.floor(box / 3) * 3;
                    const startCol = (box % 3) * 3;
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            const row = startRow + i;
                            const col = startCol + j;
                            const val = board[row][col];
                            if (val !== 0) {
                                if (seen.has(val)) {
                                    const original = seen.get(val);
                                    duplicates.add(`${row}-${col}`);
                                    duplicates.add(`${original.row}-${original.col}`);
                                }
                                seen.set(val, {row, col});
                            }
                        }
                    }
                }
                const invalidCells = Array.from(duplicates).map(s => ({ row: parseInt(s.split('-')[0]), col: parseInt(s.split('-')[1]) }));
                return { isValid: invalidCells.length === 0, invalidCells };
            }
            
            // --- Backtracking Solver ---
            
            function solveSudoku() {
                const board = getBoardState();
                const { isValid } = isValidSudoku(board);
                if (!isValid) {
                    showMessage('Cannot solve an invalid board. Please fix errors.', 'error');
                    validateCurrentBoard();
                    return;
                }
                const originalBoard = getBoardState();
                if (solve(board)) {
                    setBoardState(board, originalBoard);
                    showMessage('Solution found!', 'success');
                } else {
                    showMessage('No solution exists for this board.', 'error');
                }
            }

            function solve(board) {
                const emptySpot = findEmpty(board);
                if (!emptySpot) return true;

                const [row, col] = emptySpot;
                for (let num = 1; num <= 9; num++) {
                    if (isSafe(board, row, col, num)) {
                        board[row][col] = num;
                        if (solve(board)) {
                            return true;
                        }
                        board[row][col] = 0;
                    }
                }
                return false;
            }

            function findEmpty(board) {
                for (let i = 0; i < 9; i++) {
                    for (let j = 0; j < 9; j++) {
                        if (board[i][j] === 0) return [i, j];
                    }
                }
                return null;
            }

            function isSafe(board, row, col, num) {
                for (let x = 0; x < 9; x++) if (board[row][x] === num) return false;
                for (let x = 0; x < 9; x++) if (board[x][col] === num) return false;
                const startRow = row - row % 3, startCol = col - col % 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (board[i + startRow][j + startCol] === num) return false;
                    }
                }
                return true;
            }

            // Event Listeners
            validateBtn.addEventListener('click', validateCurrentBoard);
            clearBtn.addEventListener('click', clearBoard);
            solveBtn.addEventListener('click', solveSudoku);
            
            // Initialization
            createGrid();
            loadPuzzle(initialPuzzle);
        });
    </script>
</body>
</html>

